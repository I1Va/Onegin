$Подчистка информации при промежуточной ошибке в функции
1) Если функция алоцирует <= 1 пространст памяти, goto не применяю
2) Если п1) не выполняется, то вместо return делаю goto в конец файла, делаю
последовательные FREE (в обратном порядке), возращаю нейтральное значение

функиця отработала некоректно:
    *last_err = ERR_CODE; // передаю ошибку вверх по абсракциям.
    DEBUG(ERR_CODE)
    goto END_POINT_<i>; // i - номер блока обработки ошибки, начиная с нуля

;// КОНЕЦ ФУНКЦИИ

END_POINT_<n>
FREE(ptr) ;// ptr - указатель, алоцированный перед блоком с ошибкой <n - 1>
END_POINT_<n - 1>
FREE(ptr)
END_POINT_<n - 2>
;// перед некоторыми поинтами не стоит FREE, т.к. перед данным блоком обработки ошибки не было алоцирования перменной
END_POINT_<n - 3>
...
END_POINT_<0>

return <значение, возвращаемое в случае ошибки(int : 0, void * : NULL, float : NaN и т.д.)>
mark пишу в формате END_POINT_<номер поинта начиная с нуля>

$Правила оформления define
1)названия функций #define FUNCTION
пишу с большой буквы, т.к.
все подставляемые препроцессором блоки должны называться с большой буквы (константы например)
2) после использования функции определенной в define не ставлю <;>
чтобы подчеркнуть, что это не определенная прототипом функция
